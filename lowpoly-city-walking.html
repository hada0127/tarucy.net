<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ë¡œìš°í´ë¦¬ ë„ì‹œ í’ê²½ - ê±¸ì–´ë‹¤ë‹ˆëŠ” ì‚¬ëŒë“¤</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', sans-serif;
      overflow-x: hidden;
      background-color: #cc0000;
    }
    
    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      z-index: 1;
      pointer-events: none;
    }
    
    .scroll-container {
      height: 500vh;
      position: relative;
      z-index: 2;
      pointer-events: none;
    }
    
    .section {
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    
    .section-content {
      background: rgba(0, 0, 0, 0.7);
      padding: 2rem 3rem;
      border-radius: 16px;
      max-width: 400px;
      text-align: center;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .section-content h2 {
      font-size: 1.8rem;
      margin-bottom: 1rem;
      color: #ffffff;
    }
    
    .section-content p {
      color: #cccccc;
      line-height: 1.6;
    }
    
    .progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      height: 4px;
      background: linear-gradient(90deg, #ffffff, #ffcccc);
      z-index: 100;
      transition: width 0.1s ease-out;
    }
    
    .scroll-hint {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: #ffffff;
      font-size: 0.9rem;
      opacity: 0.8;
      animation: bounce 2s infinite;
      z-index: 10;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    
    @keyframes bounce {
      0%, 100% { transform: translateX(-50%) translateY(0); }
      50% { transform: translateX(-50%) translateY(-10px); }
    }
  </style>
</head>
<body>
  <div class="progress-bar" id="progress"></div>
  <div id="canvas-container"></div>
  
  <div class="scroll-container">
    <div class="section">
      <div class="section-content">
        <h2>ğŸ™ï¸ ë„ì‹œì˜ ì•„ì¹¨</h2>
        <p>ìŠ¤í¬ë¡¤í•˜ì—¬ ë„ì‹œë¥¼ íƒí—˜í•´ë³´ì„¸ìš”</p>
      </div>
    </div>
    
    <div class="section">
      <div class="section-content">
        <h2>ğŸš¶ ê±°ë¦¬ì˜ ì‚¬ëŒë“¤</h2>
        <p>ì‚¬ëŒë“¤ì´ ë„ì‹œë¥¼ ê±¸ì–´ë‹¤ë‹™ë‹ˆë‹¤</p>
      </div>
    </div>
    
    <div class="section">
      <div class="section-content">
        <h2>ğŸ¢ ë¹Œë”© ìˆ²</h2>
        <p>ë‹¤ì–‘í•œ ë†’ì´ì˜ ê±´ë¬¼ë“¤ì´ ë„ì‹œë¥¼ ì´ë£¹ë‹ˆë‹¤</p>
      </div>
    </div>
    
    <div class="section">
      <div class="section-content">
        <h2>ğŸŒ³ ë„ì‹œ ê³µì›</h2>
        <p>ë…¹ì§€ ê³µê°„ì´ ë„ì‹œì— ìƒê¸°ë¥¼ ë¶ˆì–´ë„£ìŠµë‹ˆë‹¤</p>
      </div>
    </div>
    
    <div class="section">
      <div class="section-content">
        <h2>ğŸŒ… ì—¬ì •ì˜ ë</h2>
        <p>ë„ì‹œ íƒí—˜ì„ ë§ˆì¹©ë‹ˆë‹¤</p>
      </div>
    </div>
  </div>
  
  <div class="scroll-hint">â†“ ìŠ¤í¬ë¡¤í•˜ì—¬ íƒí—˜í•˜ê¸°</div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    
    const scene = new THREE.Scene();
    scene.background = null;
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    document.getElementById('canvas-container').appendChild(renderer.domElement);
    
    const wireColor = 0xffffff;
    const wireOpacity = 0.9;
    
    const depthMaskMaterial = new THREE.MeshBasicMaterial({
      colorWrite: false,
      depthWrite: true,
      side: THREE.DoubleSide
    });
    
    function createOccludedWireframe(geometry, color = wireColor, opacity = wireOpacity) {
      const group = new THREE.Group();
      
      const depthMask = new THREE.Mesh(geometry, depthMaskMaterial);
      depthMask.renderOrder = 0;
      group.add(depthMask);
      
      const edges = new THREE.EdgesGeometry(geometry);
      const lineMaterial = new THREE.LineBasicMaterial({ 
        color: color,
        transparent: true,
        opacity: opacity,
        depthTest: true
      });
      const wireframe = new THREE.LineSegments(edges, lineMaterial);
      wireframe.renderOrder = 1;
      group.add(wireframe);
      
      return group;
    }
    
    // Ground
    const gridHelper = new THREE.GridHelper(200, 40, wireColor, wireColor);
    gridHelper.material.transparent = true;
    gridHelper.material.opacity = 0.3;
    scene.add(gridHelper);
    
    const groundGeometry = new THREE.PlaneGeometry(200, 200);
    const groundMask = new THREE.Mesh(groundGeometry, depthMaskMaterial);
    groundMask.rotation.x = -Math.PI / 2;
    groundMask.position.y = 0.01;
    groundMask.renderOrder = 0;
    scene.add(groundMask);
    
    // Road
    function createRoad(x, z, width, length, rotation = 0) {
      const roadGeometry = new THREE.PlaneGeometry(width, length);
      const road = createOccludedWireframe(roadGeometry, wireColor, 0.4);
      road.rotation.x = -Math.PI / 2;
      road.rotation.z = rotation;
      road.position.set(x, 0.02, z);
      scene.add(road);
    }
    
    createRoad(0, 0, 8, 200);
    createRoad(0, 0, 200, 8, Math.PI / 2);
    createRoad(-30, 0, 8, 200);
    createRoad(30, 0, 8, 200);
    
    // Building
    function createBuilding(x, z, width, depth, height, color = wireColor) {
      const group = new THREE.Group();
      
      const geometry = new THREE.BoxGeometry(width, height, depth);
      const building = createOccludedWireframe(geometry, color, 0.9);
      building.position.y = height / 2;
      group.add(building);
      
      const windowRows = Math.floor(height / 3);
      const windowCols = Math.floor(width / 2.5);
      const windowGeometry = new THREE.PlaneGeometry(1, 1.5);
      
      for (let row = 0; row < windowRows; row++) {
        for (let col = 0; col < windowCols; col++) {
          const windowMesh = createOccludedWireframe(windowGeometry, color, 0.5);
          windowMesh.position.set(
            -width/2 + 1.5 + col * 2.5,
            2 + row * 3,
            depth/2 + 0.05
          );
          group.add(windowMesh);
          
          const backWindow = createOccludedWireframe(windowGeometry, color, 0.5);
          backWindow.position.set(
            -width/2 + 1.5 + col * 2.5,
            2 + row * 3,
            -depth/2 - 0.05
          );
          backWindow.rotation.y = Math.PI;
          group.add(backWindow);
        }
      }
      
      group.position.set(x, 0, z);
      scene.add(group);
      return group;
    }
    
    const buildingPositions = [
      { x: -50, z: -40, w: 12, d: 10, h: 25 },
      { x: -50, z: -20, w: 10, d: 12, h: 35 },
      { x: -50, z: 10, w: 14, d: 10, h: 20 },
      { x: -50, z: 35, w: 10, d: 14, h: 40 },
      { x: -50, z: 60, w: 12, d: 10, h: 28 },
      { x: 50, z: -35, w: 14, d: 12, h: 45 },
      { x: 50, z: -10, w: 10, d: 10, h: 22 },
      { x: 50, z: 15, w: 12, d: 14, h: 38 },
      { x: 50, z: 40, w: 10, d: 10, h: 30 },
      { x: 50, z: 65, w: 14, d: 12, h: 35 },
      { x: -15, z: -45, w: 8, d: 8, h: 18 },
      { x: 15, z: -45, w: 10, d: 8, h: 25 },
      { x: -15, z: 45, w: 10, d: 10, h: 32 },
      { x: 15, z: 45, w: 8, d: 10, h: 22 },
      { x: -70, z: -50, w: 15, d: 12, h: 50 },
      { x: 70, z: -50, w: 12, d: 15, h: 55 },
      { x: -70, z: 50, w: 14, d: 14, h: 42 },
      { x: 70, z: 50, w: 16, d: 12, h: 48 },
    ];
    
    buildingPositions.forEach((pos) => {
      createBuilding(pos.x, pos.z, pos.w, pos.d, pos.h);
    });
    
    // Tree
    function createTree(x, z, scale = 1) {
      const group = new THREE.Group();
      
      const trunkGeometry = new THREE.CylinderGeometry(0.3 * scale, 0.5 * scale, 3 * scale, 6);
      const trunk = createOccludedWireframe(trunkGeometry, wireColor, 0.7);
      trunk.position.y = 1.5 * scale;
      group.add(trunk);
      
      const foliageGeometry = new THREE.ConeGeometry(2.5 * scale, 5 * scale, 6);
      const foliage = createOccludedWireframe(foliageGeometry, wireColor, 0.7);
      foliage.position.y = 5 * scale;
      group.add(foliage);
      
      group.position.set(x, 0, z);
      scene.add(group);
      return group;
    }
    
    const treePositions = [
      { x: -6, z: -30 }, { x: -6, z: -10 }, { x: -6, z: 10 }, { x: -6, z: 30 }, { x: -6, z: 50 },
      { x: 6, z: -25 }, { x: 6, z: -5 }, { x: 6, z: 15 }, { x: 6, z: 35 }, { x: 6, z: 55 },
      { x: -25, z: 6 }, { x: 25, z: 6 }, { x: -25, z: -6 }, { x: 25, z: -6 },
    ];
    
    treePositions.forEach(pos => {
      createTree(pos.x, pos.z, 0.8 + Math.random() * 0.4);
    });
    
    // Person with walking capability
    function createPerson(x, z, pathType, pathIndex = 0) {
      const group = new THREE.Group();
      
      const headGeometry = new THREE.BoxGeometry(0.4, 0.45, 0.4);
      const head = createOccludedWireframe(headGeometry, wireColor, 0.9);
      head.position.y = 1.65;
      group.add(head);
      
      const bodyGeometry = new THREE.BoxGeometry(0.5, 0.7, 0.3);
      const body = createOccludedWireframe(bodyGeometry, wireColor, 0.9);
      body.position.y = 1.1;
      group.add(body);
      
      const legGeometry = new THREE.BoxGeometry(0.18, 0.7, 0.2);
      
      const leftLeg = createOccludedWireframe(legGeometry, wireColor, 0.9);
      leftLeg.position.set(-0.12, 0.35, 0);
      group.add(leftLeg);
      
      const rightLeg = createOccludedWireframe(legGeometry, wireColor, 0.9);
      rightLeg.position.set(0.12, 0.35, 0);
      group.add(rightLeg);
      
      const armGeometry = new THREE.BoxGeometry(0.15, 0.55, 0.15);
      
      const leftArm = createOccludedWireframe(armGeometry, wireColor, 0.9);
      leftArm.position.set(-0.35, 1.05, 0);
      group.add(leftArm);
      
      const rightArm = createOccludedWireframe(armGeometry, wireColor, 0.9);
      rightArm.position.set(0.35, 1.05, 0);
      group.add(rightArm);
      
      group.position.set(x, 0, z);
      
      // Walking data
      group.userData = {
        walkOffset: Math.random() * Math.PI * 2,
        walkSpeed: 1.5 + Math.random() * 1.5, // ì´ë™ ì†ë„
        animSpeed: 3 + Math.random() * 2,      // ê±·ê¸° ì• ë‹ˆë©”ì´ì…˜ ì†ë„
        pathType: pathType,                     // 'vertical', 'horizontal', 'cross'
        pathIndex: pathIndex,                   // ë„ë¡œ ì¸ë±ìŠ¤
        direction: Math.random() > 0.5 ? 1 : -1, // ì´ë™ ë°©í–¥
        offset: (Math.random() - 0.5) * 3       // ë„ë¡œ ë‚´ ì¢Œìš° ì˜¤í”„ì…‹
      };
      
      scene.add(group);
      return group;
    }
    
    // ë„ë¡œ ê²½ë¡œ ì •ì˜
    const paths = {
      // ì„¸ë¡œ ë„ë¡œë“¤ (z ë°©í–¥ ì´ë™)
      vertical: [
        { x: 0, zMin: -80, zMax: 80 },      // ì¤‘ì•™ ë„ë¡œ
        { x: -30, zMin: -80, zMax: 80 },    // ì™¼ìª½ ë„ë¡œ
        { x: 30, zMin: -80, zMax: 80 },     // ì˜¤ë¥¸ìª½ ë„ë¡œ
      ],
      // ê°€ë¡œ ë„ë¡œ (x ë°©í–¥ ì´ë™)
      horizontal: [
        { z: 0, xMin: -80, xMax: 80 },      // ì¤‘ì•™ ê°€ë¡œ ë„ë¡œ
      ]
    };
    
    const people = [];
    
    // ì„¸ë¡œ ë„ë¡œì— ì‚¬ëŒ ë°°ì¹˜
    paths.vertical.forEach((path, pathIndex) => {
      for (let i = 0; i < 6; i++) {
        const z = path.zMin + Math.random() * (path.zMax - path.zMin);
        const person = createPerson(path.x, z, 'vertical', pathIndex);
        people.push(person);
      }
    });
    
    // ê°€ë¡œ ë„ë¡œì— ì‚¬ëŒ ë°°ì¹˜
    paths.horizontal.forEach((path, pathIndex) => {
      for (let i = 0; i < 6; i++) {
        const x = path.xMin + Math.random() * (path.xMax - path.xMin);
        const person = createPerson(x, path.z, 'horizontal', pathIndex);
        people.push(person);
      }
    });
    
    // ì‚¬ëŒ ì´ë™ ì—…ë°ì´íŠ¸
    function updatePerson(person, deltaTime) {
      const data = person.userData;
      const speed = data.walkSpeed * deltaTime;
      
      if (data.pathType === 'vertical') {
        const path = paths.vertical[data.pathIndex];
        
        // z ë°©í–¥ ì´ë™
        person.position.z += speed * data.direction;
        person.position.x = path.x + data.offset;
        
        // ê²½ê³„ ë„ë‹¬ ì‹œ ë°©í–¥ ì „í™˜
        if (person.position.z > path.zMax) {
          person.position.z = path.zMax;
          data.direction = -1;
        } else if (person.position.z < path.zMin) {
          person.position.z = path.zMin;
          data.direction = 1;
        }
        
        // ì´ë™ ë°©í–¥ìœ¼ë¡œ íšŒì „
        person.rotation.y = data.direction > 0 ? 0 : Math.PI;
        
      } else if (data.pathType === 'horizontal') {
        const path = paths.horizontal[data.pathIndex];
        
        // x ë°©í–¥ ì´ë™
        person.position.x += speed * data.direction;
        person.position.z = path.z + data.offset;
        
        // ê²½ê³„ ë„ë‹¬ ì‹œ ë°©í–¥ ì „í™˜
        if (person.position.x > path.xMax) {
          person.position.x = path.xMax;
          data.direction = -1;
        } else if (person.position.x < path.xMin) {
          person.position.x = path.xMin;
          data.direction = 1;
        }
        
        // ì´ë™ ë°©í–¥ìœ¼ë¡œ íšŒì „
        person.rotation.y = data.direction > 0 ? Math.PI / 2 : -Math.PI / 2;
      }
    }
    
    // ê±·ê¸° ì• ë‹ˆë©”ì´ì…˜
    function animateWalk(person, time) {
      const data = person.userData;
      const t = time * data.animSpeed + data.walkOffset;
      
      // ìœ„ì•„ë˜ ë°”ìš´ìŠ¤
      person.position.y = Math.abs(Math.sin(t * 2)) * 0.08;
      
      // ë‹¤ë¦¬ ì• ë‹ˆë©”ì´ì…˜
      if (person.children[2] && person.children[3]) {
        person.children[2].rotation.x = Math.sin(t) * 0.5;
        person.children[3].rotation.x = Math.sin(t + Math.PI) * 0.5;
      }
      
      // íŒ” ì• ë‹ˆë©”ì´ì…˜
      if (person.children[4] && person.children[5]) {
        person.children[4].rotation.x = Math.sin(t + Math.PI) * 0.4;
        person.children[5].rotation.x = Math.sin(t) * 0.4;
      }
    }
    
    // Bench
    function createBench(x, z, rotation = 0) {
      const group = new THREE.Group();
      
      const seatGeometry = new THREE.BoxGeometry(2, 0.1, 0.5);
      const seat = createOccludedWireframe(seatGeometry, wireColor, 0.8);
      seat.position.y = 0.5;
      group.add(seat);
      
      const backGeometry = new THREE.BoxGeometry(2, 0.6, 0.08);
      const back = createOccludedWireframe(backGeometry, wireColor, 0.8);
      back.position.set(0, 0.8, -0.2);
      group.add(back);
      
      const legGeometry = new THREE.BoxGeometry(0.1, 0.5, 0.4);
      
      const leg1 = createOccludedWireframe(legGeometry, wireColor, 0.8);
      leg1.position.set(-0.8, 0.25, 0);
      group.add(leg1);
      
      const leg2 = createOccludedWireframe(legGeometry, wireColor, 0.8);
      leg2.position.set(0.8, 0.25, 0);
      group.add(leg2);
      
      group.position.set(x, 0, z);
      group.rotation.y = rotation;
      scene.add(group);
      return group;
    }
    
    createBench(-8, 20, Math.PI / 2);
    createBench(8, 30, -Math.PI / 2);
    createBench(-8, 50, Math.PI / 2);
    
    // Street lamp
    function createStreetLamp(x, z) {
      const group = new THREE.Group();
      
      const poleGeometry = new THREE.CylinderGeometry(0.1, 0.15, 5, 6);
      const pole = createOccludedWireframe(poleGeometry, wireColor, 0.8);
      pole.position.y = 2.5;
      group.add(pole);
      
      const lampGeometry = new THREE.SphereGeometry(0.4, 8, 6);
      const lamp = createOccludedWireframe(lampGeometry, wireColor, 0.9);
      lamp.position.y = 5.2;
      group.add(lamp);
      
      group.position.set(x, 0, z);
      scene.add(group);
      return group;
    }
    
    const lampPositions = [
      { x: -6, z: -40 }, { x: 6, z: -20 }, { x: -6, z: 0 }, 
      { x: 6, z: 20 }, { x: -6, z: 40 }, { x: 6, z: 60 }
    ];
    lampPositions.forEach(pos => createStreetLamp(pos.x, pos.z));
    
    // Camera path
    const cameraPath = [
      { pos: new THREE.Vector3(0, 15, -60), lookAt: new THREE.Vector3(0, 5, 0) },
      { pos: new THREE.Vector3(15, 8, -30), lookAt: new THREE.Vector3(0, 3, 0) },
      { pos: new THREE.Vector3(-10, 6, 10), lookAt: new THREE.Vector3(10, 10, 20) },
      { pos: new THREE.Vector3(20, 12, 40), lookAt: new THREE.Vector3(-20, 5, 50) },
      { pos: new THREE.Vector3(0, 25, 80), lookAt: new THREE.Vector3(0, 0, 20) },
    ];
    
    let scrollProgress = 0;
    const progressBar = document.getElementById('progress');
    const scrollHint = document.querySelector('.scroll-hint');
    
    function updateScroll() {
      const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
      scrollProgress = window.scrollY / maxScroll;
      progressBar.style.width = (scrollProgress * 100) + '%';
      
      if (scrollProgress > 0.05) {
        scrollHint.style.opacity = '0';
      } else {
        scrollHint.style.opacity = '0.8';
      }
    }
    
    window.addEventListener('scroll', updateScroll);
    
    function getCameraPosition(progress) {
      const numSegments = cameraPath.length - 1;
      const segment = Math.min(Math.floor(progress * numSegments), numSegments - 1);
      const segmentProgress = (progress * numSegments) - segment;
      
      const start = cameraPath[segment];
      const end = cameraPath[segment + 1];
      
      const eased = segmentProgress * segmentProgress * (3 - 2 * segmentProgress);
      
      const pos = new THREE.Vector3().lerpVectors(start.pos, end.pos, eased);
      const lookAt = new THREE.Vector3().lerpVectors(start.lookAt, end.lookAt, eased);
      
      return { pos, lookAt };
    }
    
    // Animation loop
    let lastTime = 0;
    let time = 0;
    
    function animate(currentTime) {
      requestAnimationFrame(animate);
      
      const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
      lastTime = currentTime;
      time += deltaTime;
      
      // Camera
      const { pos, lookAt } = getCameraPosition(scrollProgress);
      camera.position.lerp(pos, 0.1);
      camera.lookAt(lookAt);
      
      // Update all people
      people.forEach(person => {
        updatePerson(person, deltaTime);
        animateWalk(person, time);
      });
      
      renderer.render(scene, camera);
    }
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    updateScroll();
    animate(0);
  </script>
</body>
</html>
